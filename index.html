<!DOCTYPE html>
<html>
<head>
  <title>Instant 3D Terrain</title>
  <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
  <canvas id="terrain" width="800" height="600"></canvas>
  <script>
    const canvas = document.getElementById('terrain');
    const gl = canvas.getContext('webgl');
    
    // Vertex shader
    const vs = `
      attribute vec3 position;
      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;
      void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    
    // Fragment shader
    const fs = `
      precision mediump float;
      void main() {
        vec3 color = vec3(
          sin(gl_FragCoord.x * 0.01), 
          cos(gl_FragCoord.y * 0.01), 
          0.5
        );
        gl_FragColor = vec4(color, 1.0);
      }
    `;
    
    // Compile shaders
    function createShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      return shader;
    }
    
    const program = gl.createProgram();
    gl.attachShader(program, createShader(gl.VERTEX_SHADER, vs));
    gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(program);
    gl.useProgram(program);
    
    // Generate procedural terrain
    const vertices = [];
    for (let x = -10; x < 10; x++) {
      for (let z = -10; z < 10; z++) {
        const y = Math.sin(x * 0.5) * Math.cos(z * 0.5) * 2;
        vertices.push(x, y, z);
      }
    }
    
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    
    const positionLoc = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
    
    // Setup matrices
    const modelViewMatrix = new Float32Array([
      1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,-5,1
    ]);
    const projectionMatrix = new Float32Array(16);
    
    // Simple perspective matrix
    const f = 1.0 / Math.tan(45 * Math.PI / 360);
    projectionMatrix[0] = f; 
    projectionMatrix[5] = f;
    projectionMatrix[10] = 1000.0 / (1.0 - 1000.0);
    projectionMatrix[11] = -1;
    projectionMatrix[14] = 1000.0 * 1.0 / (1.0 - 1000.0);
    
    // Animation loop
    let rotation = 0;
    function render() {
      rotation += 0.01;
      
      // Rotate model view
      modelViewMatrix[0] = Math.cos(rotation);
      modelViewMatrix[2] = -Math.sin(rotation);
      modelViewMatrix[8] = Math.sin(rotation);
      modelViewMatrix[10] = Math.cos(rotation);
      
      gl.uniformMatrix4fv(
        gl.getUniformLocation(program, 'modelViewMatrix'),
        false,
        modelViewMatrix
      );
      gl.uniformMatrix4fv(
        gl.getUniformLocation(program, 'projectionMatrix'),
        false,
        projectionMatrix
      );
      
      gl.clearColor(0.1, 0.1, 0.15, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertices.length / 3);
      requestAnimationFrame(render);
    }
    
    render();
  </script>
</body>
</html>
